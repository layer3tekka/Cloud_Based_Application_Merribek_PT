import { transit_realtime as tr } from "gtfs-realtime-bindings";

const MODE_URL = {
  tram:  process.env.TRAM_FEED_URL  || "",
  bus:   process.env.BUS_FEED_URL   || "",
  train: process.env.TRAIN_FEED_URL || ""
};

function setCors(res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
}

function buildUrlFor(mode) {
  return MODE_URL[mode] || "";
}

async function fetchProto(url) {
  const opts = {};
  if (process.env.AUTH_MODE === "header" && process.env.AUTH_KEY && process.env.AUTH_HEADER) {
    opts.headers = { [process.env.AUTH_HEADER]: process.env.AUTH_KEY };
  }
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(`Upstream ${r.status} ${r.statusText}`);
  const buf = Buffer.from(await r.arrayBuffer());
  return tr.FeedMessage.decode(buf);
}

function normalize(feed) {
  const out = [];
  for (const ent of feed.entity || []) {
    const tu = ent.tripUpdate;
    const ve = ent.vehicle;

    let firstStop = null;
    if (tu?.stopTimeUpdate?.length) {
      const s = tu.stopTimeUpdate[0];
      const delay = s.arrival?.delay ?? s.departure?.delay ?? null;
      firstStop = {
        stopId: s.stopId ?? null,
        arrivalDelay: s.arrival?.delay ?? null,
        departureDelay: s.departure?.delay ?? null,
        delaySeconds: delay
      };
    }

    out.push({
      id: ent.id ?? null,
      timestamp: feed.header?.timestamp?.low ?? null,
      trip: {
        trip_id: tu?.trip?.tripId ?? ve?.trip?.tripId ?? null,
        route_id: tu?.trip?.routeId ?? ve?.trip?.routeId ?? null
      },
      firstStop
    });
  }
  return { entities: out };
}

export default async function handler(req, res) {
  setCors(res);
  if (req.method === "OPTIONS") return res.status(200).end();
  try {
    const mode = (req.query.mode || "").toString().toLowerCase();
    if (!["tram","bus","train"].includes(mode)) {
      return res.status(400).json({ error: "mode must be tram|bus|train" });
    }
    const url = buildUrlFor(mode);
    if (!url) return res.status(500).json({ error: `No feed URL for ${mode}` });

    const feed = await fetchProto(url);
    const json = normalize(feed);
    res.setHeader("Content-Type", "application/json");
    return res.status(200).send(JSON.stringify(json));
  } catch (err) {
    console.error(err);
    return res.status(502).json({ error: "Upstream fetch failed" });
  }
}
